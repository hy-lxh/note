
        <!DOCTYPE html>
         <html lang="en">
         <head>
	     <meta charset="UTF-8">
         <meta name="keywords" content="react路由,博客,前端"/>
         <meta name="description" content="react路由详情笔记"/>
         <!--<meta http-equiv="content-security-policy" content="default-src self"/>-->
	     <title>react路由</title>
        </head>
        <link rel="stylesheet" href="../main.css">
        <body>
        <div class="message_box"></div>
        <div class="content">
           <div id="view">
              <div>
                <div class="bs_content">
                   <h2 id='标签式路由' class='BZ143436'>标签式路由</h2><div><div class='quote'>首先下载react-router-dom: npm i react-router-dom -D</div></div><h3 id='react-router-dom组件' class='HM608790'>react-router-dom组件</h3><h4 id='Link' class='EN369569'>Link</h4><div><div class='quote'>通过使用Link标签跳转路由 身上有个属性to表示路由地址</div></div><div><div class='quote'>Link默认是用push模式,还可以返回会留下痕迹，而如果要开启replace模式就直接在Link身上加一个replace={true}</div></div><div><div class='quote'>还有用BrowserRouter或者HashRouter包起来</div></div><div><div class='quote'>然后就是显示Route 它身上有个path就表示路由，component就是组件,然后最基本的路由就搭起来了</div></div><div><div class='quote'>BrowserRouter要把要跳转的Link和Route包在一起才能实现跳转，如果是全局路由可以直接将App组件包起来</div></div><h4 id='NavLink' class='ad609967'>NavLink</h4><div><div class='quote'>这个是个路由导航加上高亮，在哪个就加在哪个身上，默认是加上一个active的类名</div></div><div><div class='quote'>如果不是叫active的类名，就得在NavLink组件身上添加一个activeClassName属性，是什么类名就是什么属性值</div></div><div><div class='quote'>它还可以通过children属性可以自定义标签体内容，在自定义组件使用闭合组件写法，可以将组件的标签体内容传给组件，在props身上的children属性上</div></div><h4 id='BrowserRouter和HashRouter' class='GG941253'>BrowserRouter和HashRouter</h4><div><div class='quote'>BrowserRouter是history路由，HashRouter是哈希路由，不同的，这是要包裹同一个路由的Link和Route显示</div></div><h4 id='Route' class='NK382779'>Route</h4><div><div class='quote'>路由显示区域，身上有两个属性，component对应显示的组件component={组件名},path="路由地址"，它可以进行模糊匹配，比如Link里面的to属性写的是/home/a/b,而path里面写的是/home也能匹配到</div></div><div><div class='quote'>禁止模糊匹配使用exact属性 直接加上一个exact或者exact={true},那么to和path里面的内容要一模一样才能匹配上，如果有子集路由就不要开启，会匹配不上</div></div><h4 id='Switch' class='ig094345'>Switch</h4><div><div class='quote'>通过Switch包裹Route只要匹配上相应的，就不会再往下匹配，而不用就会继续往下匹配</div></div><h4 id='Redirect' class='De026816'>Redirect</h4><div><div class='quote'>重定向路由，如果所有的路由都没匹配上就会匹配在这个</div></div><div><div class='quote'>它身上也是一个to属性</div></div><h3 id='路由传参' class='BN146538'>路由传参</h3><h4 id='params传参' class='Ee961599'>params传参</h4><div><div class='quote'>直接把想要传递的参数写在Link中的to属性的url后面，通过/分开,比如/home/detail/这是我想传的id/这是我想传的name/.....</div></div><div><div class='quote'>然后再在Route的path属性中接收,就比如上一个例子，path里面就应该是/home/detail/:id/:name，这个变量是可以自己随便命名的</div></div><div><div class='quote'>然后就可以在Detail这里面通过this.props.match.params拿了，这是一个对象，里面就有刚刚的那个id和name的属性</div></div><h4 id='search传参' class='Ag726643'>search传参</h4><div><div class='quote'>首先在Link的to属性的url身上，比如/home/detail/?id=想传递的id and name=想传递name</div></div><div><div class='quote'>他不用在Route身上声明接收</div></div><div><div class='quote'>它在Detail里面通过this.props.location.search接收,就收到的就是"?id=传的id and name=传的name",然后通过引入querystring将它解析，代码如下</div></div><pre class='code' data-key='pre'>
                        <div class="code_header">
                          <div class="circle">
                           <div class="circle1"></div>
                           <div class="circle2"></div>
                           <div class="circle3"></div>
                          </div>
                          <svg title="复制" t="1649216860822" class="copy_code icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3280" width="24" height="24"><path d="M441.47 537.05h186.18v59.22H441.47zM441.47 671.04h280.56v59.22H441.47z" p-id="3281"></path><path d="M685.92 217.95c-0.62-0.65-1.27-1.25-1.93-1.84l-6.85-7.18h-9.52a29.56 29.56 0 0 0-6.31 0h-59.93l1.81-1.73-86.3-90.62H221.06a60.21 60.21 0 0 0-60.15 60.15V742.1a60.21 60.21 0 0 0 60.15 60.15h100.11v32.2a60.21 60.21 0 0 0 60.15 60.15h440.82a60.21 60.21 0 0 0 60.15-60.15V424L746.8 282z m93.95 184.69l-92.81-4.54a0.85 0.85 0 0 1-0.6-0.93l4.25-88.22 12.61 13.22zM221.06 743a1 1 0 0 1-0.93-0.93V176.73a1 1 0 0 1 0.93-0.93h270.45l31.55 33.13H381.32a60.21 60.21 0 0 0-60.15 60.15V743z m601.09 92.35H381.32a1 1 0 0 1-0.93-0.93V269.08a1 1 0 0 1 0.93-0.93h252.07l-6.08 126.27v0.12c-1.46 33.12 24.17 61.25 57 62.71L823.07 464v370.45a1 1 0 0 1-0.93 0.93z" p-id="3282"></path></svg>
                        </div>
                        <div class='indexPre'><div class='index'>1.</div><div class='index'>2.</div><div class='index'>3.</div><div class='index'>4.</div><div class='index'>5.</div></div><div class="codePre"><code data-key='xmp'><span class="let">import </span>qs<span class="let"> from </span><span class="string">"querystring"</span></code><code data-key='xmp'><span class="let">let </span><span class="log">{</span>search<span class="log">}</span> <span class="let">=</span> <span class="let">this</span><span class="log">.</span><span class="title1">props</span><span class="log">.</span><span class="title1">location</span><span class="log">.</span><span class="title1">search</span>;</code><code data-key='xmp'>qs<span class="log">.</span><span class="title1">stringify</span><span class="log">(</span><span class="log">)</span><span class="green">//可以将一个对象转换为urlencoded编码的字符串</span></code><code data-key='xmp'>qs<span class="log">.</span><span class="title1">json</span><span class="log">(</span><span class="log">)</span><span class="green">//可以将urlencoded编码的字符串解析成对象</span></code><code data-key='xmp'>search <span class="let">=</span> qs<span class="log">.</span><span class="title1">json</span><span class="log">(</span>search<span class="log">.</span><span class="title1">slice</span><span class="log">(</span>1<span class="log">)</span><span class="log">)</span><span class="green">//把前面的问号去掉用search<span class="log">.</span><span class="title1">slice</span></span></code></div></pre><h4 id='传递state参数' class='hi635057'>传递state参数</h4><div><div class='quote'>这个是通过Link身上的to传一个对象</div></div><div><div class='quote'>to={{pathname: "url地址",state: {属性:属性值}}}</div></div><div><div class='quote'>不用在Route里面声明接收，在地址栏也不会显示我所传的参数内容</div></div><div><div class='quote'>然后在对应的组件里面通过this.props.location.state取出对应的传参内容，是一个对象，那边传了个什么state这边接收到的就是什么state</div></div><div><div class='quote'>虽然地址栏没有传参的内容，但是刷新了传参内容也还是在的</div></div><h2 id='编程式路由' class='Me921743'>编程式路由</h2><h3 id='replace模式' class='eZ300620'>replace模式</h3><h4 id='传state参数' class='Ge414326'>传state参数</h4><div><div class='quote'>this.props.history.replace(url,state);</div></div><h4 id='传params参数' class='FE388875'>传params参数</h4><div><div class='quote'>this.props.history.replace(url 传参内容)；</div></div><div><div class='quote'>Route的path就要使用params类型的</div></div><h4 id='传search参数' class='IZ865618'>传search参数</h4><div><div class='quote'>this.props.history.replace(url?ulrencoded编码的格式写上去);</div></div><div><div class='quote'>同理在相应组件中接收时要通过qs解析然后使用</div></div><h3 id='push模式' class='EH977939'>push模式</h3><h4 id='传state参数' class='dD667039'>传state参数</h4><div><div class='quote'>this.props.history.push(url,state);</div></div><h4 id='传params参数' class='YD181682'>传params参数</h4><div><div class='quote'>this.props.history.push(url 传参内容)；</div></div><div><div class='quote'>Route的path就要使用params类型的</div></div><h4 id='传search参数' class='cI901370'>传search参数</h4><div><div class='quote'>this.props.history.push(url?ulrencoded编码的格式写上去);</div></div><div><div class='quote'>同理在相应组件中接收时要通过qs解析然后使用</div></div><h3 id='返回上一级' class='He694293'>返回上一级</h3><div><div class='quote'>this.props.history.goBack();</div></div><div><div class='quote'>this.props.history.go(-1);传的是几就退几</div></div><div><div class='quote'>这种只能是通过push模式跳转的才能回退</div></div><h3 id='前往下一级' class='eZ032821'>前往下一级</h3><div><div class='quote'>this.props.history.goForward();</div></div><div><div class='quote'>this.props.history.go(1);传几就前进几</div></div><div><div class='quote'>这种也是只能在push模式下使用</div></div><h3 id='WithRouter' class='XC837334'>WithRouter</h3><div><div class='quote'>一般的组件的props身上是没有路由提供的三个location、history、match属性，只有路由组件才有，但是又想使用，怎么办呢?就要用到WithRouter了</div></div><div><div class='quote'>export default组件时不要直接export，首先在react-router-dom的身上引入WithRouter，然后将要导出的组件用WithRouter包裹一下就可以使用路由组件独有的api了</div></div><h3 id='BrowserRouter和HashRouter的区别' class='NI954712'>BrowserRouter和HashRouter的区别</h3><h4 id='底层原理不同' class='GC694527'>底层原理不同</h4><div><div class='quote'>BrowserRouter是使用的h5提供的historyAPI，不适用IE9及以下的网页，HashRouter是使用url的哈希值，兼容IE9以下的网页(当然你自己写的代码也要兼容)</div></div><h4 id='path表现形式不一样' class='ED859655'>path表现形式不一样</h4><div><div class='quote'>HashRouter路径会带有#,BrowserRouter不会带有</div></div><h4 id='刷新后对state传参的影响' class='fg897765'>刷新后对state传参的影响</h4><div><div class='quote'>rowserRouter刷新后不会影响，因为state是存储在history身上的</div></div><div><div class='quote'>而HashRouter会影响state，因为它没有使用history，会导致state参数丢失</div></div>
                </div>
                <div class="rightDraw">
                <div class="menu"><div class="directory">目录</div><ul class="menuCon"><li class="menu_li"><a href="#标签式路由" id="BZ143436">标签式路由</a><ul class="menuCon_1"><li class="menu_li0"><a href="#react-router-dom组件" id="HM608790">react-router-dom组件</a><ul class="menuCon_2"><li class="menu_li0"><a href="#Link" id="EN369569">Link</a></li><li class="menu_li1"><a href="#NavLink" id="ad609967">NavLink</a></li><li class="menu_li2"><a href="#BrowserRouter和HashRouter" id="GG941253">BrowserRouter和HashRouter</a></li><li class="menu_li3"><a href="#Route" id="NK382779">Route</a></li><li class="menu_li4"><a href="#Switch" id="ig094345">Switch</a></li><li class="menu_li5"><a href="#Redirect" id="De026816">Redirect</a></li></ul></li><li class="menu_li1"><a href="#路由传参" id="BN146538">路由传参</a><ul class="menuCon_3"><li class="menu_li0"><a href="#params传参" id="Ee961599">params传参</a></li><li class="menu_li1"><a href="#search传参" id="Ag726643">search传参</a></li><li class="menu_li2"><a href="#传递state参数" id="hi635057">传递state参数</a></li></ul></li></ul></li><li class="menu_li"><a href="#编程式路由" id="Me921743">编程式路由</a><ul class="menuCon_1"><li class="menu_li0"><a href="#replace模式" id="eZ300620">replace模式</a><ul class="menuCon_2"><li class="menu_li0"><a href="#传state参数" id="Ge414326">传state参数</a></li><li class="menu_li1"><a href="#传params参数" id="FE388875">传params参数</a></li><li class="menu_li2"><a href="#传search参数" id="IZ865618">传search参数</a></li></ul></li><li class="menu_li1"><a href="#push模式" id="EH977939">push模式</a><ul class="menuCon_3"><li class="menu_li0"><a href="#传state参数" id="dD667039">传state参数</a></li><li class="menu_li1"><a href="#传params参数" id="YD181682">传params参数</a></li><li class="menu_li2"><a href="#传search参数" id="cI901370">传search参数</a></li></ul></li><li class="menu_li2"><a href="#返回上一级" id="He694293">返回上一级</a></li><li class="menu_li3"><a href="#前往下一级" id="eZ032821">前往下一级</a></li><li class="menu_li4"><a href="#WithRouter" id="XC837334">WithRouter</a></li><li class="menu_li5"><a href="#BrowserRouter和HashRouter的区别" id="NI954712">BrowserRouter和HashRouter的区别</a><ul class="menuCon_4"><li class="menu_li0"><a href="#底层原理不同" id="GC694527">底层原理不同</a></li><li class="menu_li1"><a href="#path表现形式不一样" id="ED859655">path表现形式不一样</a></li><li class="menu_li2"><a href="#刷新后对state传参的影响" id="fg897765">刷新后对state传参的影响</a></li></ul></li></ul></li></ul></div>
                </div>
              </div>
           </div>
           <svg t="1648304059372" class="icon up" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3132" width="200" height="200"><path d="M832 64 192 64C121.6 64 64 121.6 64 192l0 640c0 70.4 57.6 128 128 128l640 0c70.4 0 128-57.6 128-128L960 192C960 121.6 902.4 64 832 64zM762.24 759.04c-12.8 12.8-33.28 12.8-45.44 0L513.92 560l-202.24 199.04c-12.8 12.8-33.28 12.8-45.44 0-12.8-12.8-12.8-32.64 0-45.44l224-220.16c6.4-6.4 15.36-9.6 24.32-8.96C522.88 483.84 531.2 487.04 538.24 493.44l224 220.16C775.04 726.4 775.04 746.24 762.24 759.04zM762.24 503.04c-12.8 12.8-33.28 12.8-45.44 0L513.92 304 311.68 503.04c-12.8 12.8-33.28 12.8-45.44 0-12.8-12.8-12.8-32.64 0-45.44l224-220.16c6.4-6.4 15.36-9.6 24.32-8.96C522.88 227.84 531.2 231.04 538.24 237.44l224 220.16C775.04 470.4 775.04 490.24 762.24 503.04z" p-id="3133" fill="#ffffff"></path></svg>
        </div>
        </body>
           <script>let titles = [{"title":"标签式路由","id":"标签式路由","index":2,"class":"BZ143436","children":[{"title":"react-router-dom组件","id":"react-router-dom组件","index":3,"class":"HM608790","children":[{"title":"Link","id":"Link","index":4,"class":"EN369569"},{"title":"NavLink","id":"NavLink","index":4,"class":"ad609967"},{"title":"BrowserRouter和HashRouter","id":"BrowserRouter和HashRouter","index":4,"class":"GG941253"},{"title":"Route","id":"Route","index":4,"class":"NK382779"},{"title":"Switch","id":"Switch","index":4,"class":"ig094345"},{"title":"Redirect","id":"Redirect","index":4,"class":"De026816"}]},{"title":"路由传参","id":"路由传参","index":3,"class":"BN146538","children":[{"title":"params传参","id":"params传参","index":4,"class":"Ee961599"},{"title":"search传参","id":"search传参","index":4,"class":"Ag726643"},{"title":"传递state参数","id":"传递state参数","index":4,"class":"hi635057"}]}]},{"title":"编程式路由","id":"编程式路由","index":2,"class":"Me921743","children":[{"title":"replace模式","id":"replace模式","index":3,"class":"eZ300620","children":[{"title":"传state参数","id":"传state参数","index":4,"class":"Ge414326"},{"title":"传params参数","id":"传params参数","index":4,"class":"FE388875"},{"title":"传search参数","id":"传search参数","index":4,"class":"IZ865618"}]},{"title":"push模式","id":"push模式","index":3,"class":"EH977939","children":[{"title":"传state参数","id":"传state参数","index":4,"class":"dD667039"},{"title":"传params参数","id":"传params参数","index":4,"class":"YD181682"},{"title":"传search参数","id":"传search参数","index":4,"class":"cI901370"}]},{"title":"返回上一级","id":"返回上一级","index":3,"class":"He694293"},{"title":"前往下一级","id":"前往下一级","index":3,"class":"eZ032821"},{"title":"WithRouter","id":"WithRouter","index":3,"class":"XC837334"},{"title":"BrowserRouter和HashRouter的区别","id":"BrowserRouter和HashRouter的区别","index":3,"class":"NI954712","children":[{"title":"底层原理不同","id":"底层原理不同","index":4,"class":"GC694527"},{"title":"path表现形式不一样","id":"path表现形式不一样","index":4,"class":"ED859655"},{"title":"刷新后对state传参的影响","id":"刷新后对state传参的影响","index":4,"class":"fg897765"}]}]}];</script>
           <script src="../index.js" type="text/javascript"></script>
           </html>
            